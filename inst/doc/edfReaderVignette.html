<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jan Vis" />

<meta name="date" content="2016-03-28" />

<title>edfReader vignette</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div class="fluid-row" id="header">


<h1 class="title">edfReader vignette</h1>
<h4 class="author"><em>Jan Vis</em></h4>
<h4 class="date"><em>2016-03-28</em></h4>

</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The <a href="http://www.edfplus.info">European Data Format</a> (EDF) is a simple and flexible format for exchange and storage of multichannel biological and physical signals. It was developed by a few European ‘medical’ engineers who first met at the 1987 international Sleep Congress in Copenhagen. See <a href="http://www.edfplus.info/" class="uri">http://www.edfplus.info/</a></p>
<p>The original EDF specification has been expanded in several ways. EDF+ supports the addition of annotations and non-continuous recordings. The <a href="http://www.biosemi.com/faq/file_format.htm">BioSemi Data Format</a> BDF format uses 24 bits per sample (in stead of the 16 bits per sample in EDF). And <a href="http://www.teuniz.net/edfbrowser/bdfplus%20format%20description.html">BDF+</a> is an EDF+ like extension of BDF.</p>
<p>This packages supports all these variants.</p>
<p>Both EDF and BDF files consist of an header followed by one or more data records with the recorded signals, either ordinary signals or annotation signals.</p>
<p>This package follows this structure by providing two basic functions: readEdfHeader and readEdfSignals (see the help pages for details)</p>
<p>The examples below are based on the following files:</p>
<ul>
<li><p>AFile an EDF+ file with a continuous recording of 2 ordinary signals, two annotation signals and a sub second start specification</p></li>
<li><p>BFile a BDF+ file with a continuous recording of 11 ordinary signals and one annotation signal</p></li>
<li><p>CFile an EDF+ file with a continuous recording of 11 ordinary signals and one annotation signal</p></li>
<li><p>DFile an EDF+ file with a discontinuous recording of 11 ordinary signals and one annotation signal</p></li>
</ul>
<p>The BFile, CFile and DFile are derived from the “test_generator_2” test files from <a href="http://www.teuniz.net/edf_bdf_testfiles" class="uri">http://www.teuniz.net/edf_bdf_testfiles</a>. The AFile is derived from the “test_generator8” file received from Teunis van Beelen by private communications.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">libDir &lt;-<span class="st"> </span><span class="kw">system.file</span> (<span class="st">&quot;extdata&quot;</span>, <span class="dt">package=</span><span class="st">&quot;edfReader&quot;</span>)
AFile &lt;-<span class="st"> </span><span class="kw">paste</span> (libDir, <span class="st">'/edfAnnonC.edf'</span>, <span class="dt">sep=</span><span class="st">''</span>) <span class="co"># a file with 2 annotation signals</span>
BFile &lt;-<span class="st"> </span><span class="kw">paste</span> (libDir, <span class="st">'/bdfPlusC.bdf'</span> , <span class="dt">sep=</span><span class="st">''</span>) <span class="co"># a continuously recorded BDF file</span>
CFile &lt;-<span class="st"> </span><span class="kw">paste</span> (libDir, <span class="st">'/edfPlusC.edf'</span> , <span class="dt">sep=</span><span class="st">''</span>) <span class="co"># a continuously recorded EDF file</span>
DFile &lt;-<span class="st"> </span><span class="kw">paste</span> (libDir, <span class="st">'/edfPlusD.edf'</span> , <span class="dt">sep=</span><span class="st">''</span>) <span class="co"># a discontinuously recorded EDF file</span></code></pre></div>
</div>
<div id="edf-headers-objects" class="section level1">
<h1>EDF headers objects</h1>
<div id="introduction-1" class="section level2">
<h2>Introduction</h2>
<p>The readEdfHeader function returns a list of class ‘ebdfHeader’ with all the data from the EDF or BDF file header. Part of this list is a data frame of class ‘ebdfSHeader’ which contains the signal headers.</p>
</div>
<div id="the-ebdfheader" class="section level2">
<h2>The ebdfHeader</h2>
<p>A file header can be read with readEdfHeader()</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span> (edfReader)
AHdr  &lt;-<span class="st"> </span><span class="kw">readEdfHeader</span> (AFile)
BHdr  &lt;-<span class="st"> </span><span class="kw">readEdfHeader</span> (BFile)
CHdr  &lt;-<span class="st"> </span><span class="kw">readEdfHeader</span> (CFile)            
DHdr  &lt;-<span class="st"> </span><span class="kw">readEdfHeader</span> (DFile)                  </code></pre></div>
<p>Summaries of the header data can be shown with the S3 summary () and print() functions</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BHdr</code></pre></div>
<pre><code>##  Patient               : X X X X 
##  RecordingId           : Startdate 10-DEC-2009 X X test_generator 
##  StartTime             : 2009-12-10 12:45:54 
##  Continuous recording  : TRUE 
##  Signal labels         : squarewave, ramp, pulse, ECG, noise, sine 1 Hz, sine 8 Hz, sine 8.5 Hz, sine 15 Hz, sine 17 Hz, sine 50 Hz, BDF Annotations</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span> (AHdr)</code></pre></div>
<pre><code>##  File name             : /Library/Frameworks/R.framework/Versions/3.2/Resources/library/edfReader/extdata/edfAnnonC.edf 
##  File type             : EDF+ 
##  Version               : 0 
##  Patient               : X X X X 
##  RecordingId           : Startdate 01-JAN-2000 X X X 
##  StartTime             : 2000-01-01 14:15:16.7 
##  Continuous recording  : TRUE 
##  Recorded period       : 1.2 sec 
##  Ordinary signals      : 2 
##  Annotation signals    : 2 
##  Signal labels         : EDF Annotations, Channel 1, EDF Annotations, Channel 2 
##  R signal names        : EDF Annotations-1, Channel 1, EDF Annotations-2, Channel 2 
##  Note                  : duplicate label names</code></pre>
<p>The summary() provides somewhat more information than the print() function. For all details use str().</p>
<p>edfAnnonC.edf contains two annotation. These signals must have the same label. As edfReader names signals after their labels (see below), distinguished names are created by appending ‘-1’ and ‘-2’ to the labels.</p>
<p>NOTE       Actually, the startTime fraction .7 is not read from the edf/bdf file header but from the first data record. For details, see the section “Samples, time and periods”.</p>
</div>
<div id="the-ebdfsheader" class="section level2">
<h2>The ebdfSHeader</h2>
<p>Summaries of the signal header data can be shown with the S3 print() and summary () functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AHdr$sHeader</code></pre></div>
<pre><code>##  Signal labels         : EDF Annotations, Channel 1, EDF Annotations, Channel 2 
##  R signal names        : EDF Annotations-1, Channel 1, EDF Annotations-2, Channel 2 
##  Note                  : duplicate label names</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span> (CHdr$sHeader)</code></pre></div>
<pre><code>##    signal           label            name transducer sampleRate preFilter
## 1       1      squarewave      squarewave                   200          
## 2       2            ramp            ramp                   200          
## 3       3           pulse           pulse                   200          
## 4       4             ECG             ECG                   200          
## 5       5           noise           noise                   200          
## 6       6       sine 1 Hz       sine 1 Hz                   200          
## 7       7       sine 8 Hz       sine 8 Hz                   200          
## 8       8     sine 8.5 Hz     sine 8.5 Hz                   200          
## 9       9      sine 15 Hz      sine 15 Hz                   200          
## 10     10      sine 17 Hz      sine 17 Hz                   200          
## 11     11      sine 50 Hz      sine 50 Hz                   200          
## 12     12 EDF Annotations EDF Annotations                    NA</code></pre>
</div>
</div>
<div id="edf-signal-objects" class="section level1">
<h1>EDF signal objects</h1>
<div id="introduction-2" class="section level2">
<h2>Introduction</h2>
<p>The readEdfSignals function with simplify=FALSE returns a list of class ‘ebdfSignals’ with the signals selected from the EDF / BDF file.</p>
<p>The signals in this list are of the following :</p>
<ul>
<li><p>continuous signals<br />
of class ‘ebdfCSignal’ which may result from all types of EDF(+)/BDF(+) files</p></li>
<li><p>fragmented signals<br />
of class ‘ebdfFSignal’ which result from EDF+D and BDF+D files only</p></li>
<li><p>annotation signals<br />
of class ‘ebdfASignal’ which may result from all types of EDF+ and BDF+ files.</p></li>
</ul>
</div>
<div id="reading-the-whole-recording-of-all-signals" class="section level2">
<h2>Reading the whole recording of all signals</h2>
<p>The signals in an EDF or BDF file can be read with the readEdfSignals function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ASignals &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (AHdr)
ASignals</code></pre></div>
<pre><code>## Annotation signal: 
##   signal annotations      from     till
## 1    1,3           8 0.749 sec 1.89 sec
## Ordinary signals: 
##  Continuous recording    : TRUE 
##  Period read             : 1.2 sec = whole recording 
##           signal     label transducer sampleRate samples preFilter
## Channel 1      2 Channel 1                 30000   36000          
## Channel 2      4 Channel 2                 20000   24000</code></pre>
<p>NOTE 1     See below in case the file contains only one signal.</p>
<p>NOTE 2     The annotation signal number ‘1,3’ indicates that the ‘ebdfASignal’ annotation object contains the annotations from both signals 1 and 3. This can be prevented by using the ‘mergeASignals=FALSE’ option.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DSignals &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (DHdr)
DSignals</code></pre></div>
<pre><code>## Annotation signal: 
##   signal annotations  from  till
## 1     12           1 0 sec 0 sec
## Ordinary signals: 
##  Continuous recording    : FALSE 
##  Period read             : 20 sec = whole recording 
##             signal       label transducer sampleRate samples preFilter
## squarewave       1  squarewave                   200    4000          
## ramp             2        ramp                   200    4000          
## pulse            3       pulse                   200    4000          
## ECG              4         ECG                   200    4000          
## noise            5       noise                   200    4000          
## sine 1 Hz        6   sine 1 Hz                   200    4000          
## sine 8 Hz        7   sine 8 Hz                   200    4000          
## sine 8.5 Hz      8 sine 8.5 Hz                   200    4000          
## sine 15 Hz       9  sine 15 Hz                   200    4000          
## sine 17 Hz      10  sine 17 Hz                   200    4000          
## sine 50 Hz      11  sine 50 Hz                   200    4000</code></pre>
<p>By default all fragments in a discontinuously recorded signals will be concatenated into one signal with the gaps filled with NA values. This can be prevented by using the ‘fragments=TRUE’ option.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DSignalsF &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (DHdr, <span class="dt">fragments =</span> <span class="ot">TRUE</span>)
DSignalsF</code></pre></div>
<pre><code>## Annotation signal: 
##   signal annotations  from  till
## 1     12           1 0 sec 0 sec
## Ordinary signals: 
##  Continuous recording    : FALSE 
##  Period read             : 20 sec = whole recording 
##             signal       label transducer sampleRate samples preFilter
## squarewave       1  squarewave                   200       1          
## ramp             2        ramp                   200       1          
## pulse            3       pulse                   200       1          
## ECG              4         ECG                   200       1          
## noise            5       noise                   200       1          
## sine 1 Hz        6   sine 1 Hz                   200       1          
## sine 8 Hz        7   sine 8 Hz                   200       1          
## sine 8.5 Hz      8 sine 8.5 Hz                   200       1          
## sine 15 Hz       9  sine 15 Hz                   200       1          
## sine 17 Hz      10  sine 17 Hz                   200       1          
## sine 50 Hz      11  sine 50 Hz                   200       1</code></pre>
<p>A summary of the list of signals can be shown with the S3 summary () functions. For this ‘ebdfSignals’ objects it shows the same data as the S3 print function (see above). For object details use the str() function.</p>
</div>
<div id="reading-a-selection-of-signals" class="section level2">
<h2>Reading a selection of signals</h2>
<p>The reading of signals can be restricted to specific set by using the signals parameter. Signals can be identified by their signal number, label, name, or signal type (‘Ordinary’ or ‘Annotations’). Also, the list may contain duplicates. The following 3 designations refer e.g. to the same signal.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CSignals8 &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (CHdr, <span class="dt">signals=</span><span class="kw">c</span>(<span class="dv">8</span>, <span class="st">&quot;8&quot;</span>, <span class="st">&quot;sine 8.5 Hz&quot;</span>))
CSignals8</code></pre></div>
<pre><code>##  Signal number           : 8 
##  Label                   : sine 8.5 Hz 
##  StartTime               : 2009-12-10 12:44:02 
##  Continuous recording    : TRUE 
##  Recorded period         : 20 sec 
##  Period read             : 20 sec 
##  Transducer              :  
##  Range                   : -1000 : 1000 uV 
##  Prefilter               :  
##  Bits per sample         : 16 
##  Sample rate             : 200 
##  Number of samples       : 4000</code></pre>
<p>NOTE       As in this case only one signal was read, the list of one was simplified to a singe ‘ebdfCSignal’ object. This could be prevented by using the ‘simplify=FALSE’ parameter.</p>
<p>EXAMPLE       readEdfSignals (CHdr, signals=7, simplify=FALSE)[[1]] and readEdfSignals (CHdr, signals=7) will return the same object.</p>
</div>
<div id="reading-a-selected-period" class="section level2">
<h2>Reading a selected period</h2>
<p>If required the reading can be restricted also to a particular period. A period is identified with the ‘from’ and ‘till’ parameters which specify a time in seconds relative to start of the recording.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ASignalsPeriod    &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (AHdr, <span class="dt">from=</span><span class="fl">0.7</span>, <span class="dt">till=</span><span class="fl">1.8</span>)
ASignalsPeriod</code></pre></div>
<pre><code>## Annotation signal: 
##   signal annotations      from    till
## 1    1,3           6 0.749 sec 1.8 sec
## Ordinary signals: 
##  Continuous recording    : TRUE 
##  Period read             : 0.5 sec starting at 0.7 sec till the end 
##           signal     label transducer sampleRate samples preFilter
## Channel 1      2 Channel 1                 30000   15000          
## Channel 2      4 Channel 2                 20000   10000</code></pre>
<p>NOTE 1     The annotations included are those with an onset up to and including 1.8 sec. The onset for an annotation may be outside the recorded period.</p>
<p>NOTE 2     Because the recorded period is only 1.2 sec (see above or use summary(ASignalsPeriod)), the period read will not be [0.7, 1.8) but only [0.7, 1,2).</p>
<p>NOTE 3     For time and rounding details see the section “Samples, time and periods”</p>
<p>Summaries of a list of signals can be shown with the S3 print() and summary () functions.</p>
</div>
<div id="ordinary-signals-continuously-recorded" class="section level2">
<h2>Ordinary signals, continuously recorded</h2>
<p>Summaries of a continuously recorded ordinary signal can be shown with the S3 print() and summary () functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CSignals &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (CHdr)
<span class="kw">summary</span> (CSignals$pulse)         <span class="co"># edfReader names signals after their label</span></code></pre></div>
<pre><code>##  Signal number           : 3 
##  Label                   : pulse 
##  StartTime               : 2009-12-10 12:44:02 
##  Continuous recording    : TRUE 
##  Recorded period         : 20 sec 
##  Period read             : 20 sec 
##  Transducer              :  
##  Range                   : -1000 : 1000 uV 
##  Prefilter               :  
##  Bits per sample         : 16 
##  Sample rate             : 200 
##  Number of samples       : 4000 
##  Signal summary          :</code></pre>
<pre><code>##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
##  0.01526  0.01526  0.01526  2.01500  0.01526 99.99000</code></pre>
</div>
<div id="ordinary-signals-not-continuously-recorded" class="section level2">
<h2>Ordinary signals, not continuously recorded</h2>
<p>Ordinary signals that are not continuously recorded can be read in two different ways:</p>
<ul>
<li><p>as a ‘continuous’ sequence of samples with ‘NA’ values filling the gaps (use ‘fragments=FALSE’, the default).<br />
The result is of class ‘ebdfCSignal’ (the same as for a continuously recorded signal).</p></li>
<li><p>as a number fragments of continuously recorded parts (use ‘fragments=TRUE’)<br />
The result is of class ‘ebdfFSignal’.</p></li>
</ul>
<p>The latter method will use a more complex data structure, the first may result in a (much too) huge object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CDSignals &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (DHdr, <span class="dt">from=</span><span class="fl">5.1</span>, <span class="dt">till=</span><span class="dv">18</span>)
FDSignals &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span> (DHdr, <span class="dt">fragments=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>The objects of class ‘ebdfCSignal’ are printed and summarised in the same way as continuously recorded signals.</p>
<p>Summaries of a not continuously recorded ordinary signal stored in fragments can be shown with the S3 print() and summary () functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span> (FDSignals$<span class="st">`</span><span class="dt">sine 8.5 Hz</span><span class="st">`</span>)         <span class="co"># note the &quot;`&quot; quotes for a name with spaces.</span></code></pre></div>
<pre><code>##  Signal number           : 8 
##  Label                   : sine 8.5 Hz 
##  StartTime               : 2009-12-10 12:44:02 
##  Continuous recording    : FALSE 
##  Total period            : 20 sec 
##  Recorded period         : 11 sec 
##  Read from total period  : 20 sec 
##  Transducer              :  
##  Range                   : -1000 : 1000 uV 
##  Prefilter               :  
##  Bits per sample         : 16 
##  Sample rate             : 200 
##  Number of fragments     : 6 
##   fragment start samples   Min. X1st.Qu.   Median     Mean X3rd.Qu.  Max.
## 1        1     0     200 -99.87   -65.22  9.41500  3.73800    71.82 99.99
## 2        2     2     200 -99.87   -65.22  9.41500  3.73800    71.82 99.99
## 3        3     4    1200 -99.96   -70.70  0.01526  0.01526    70.73 99.99
## 4        4    12     200 -99.87   -65.22  9.41500  3.73800    71.82 99.99
## 5        5    15     200 -99.96   -71.79 -9.38400 -3.70800    65.25 99.90
## 6        6    19     200 -99.96   -71.79 -9.38400 -3.70800    65.25 99.90
## All fragments:
##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## -99.96000 -70.70000   0.01526   0.35370  70.73000  99.99000</code></pre>
<p>NOTE       In case of more then 10 fragments, the list of fragments summaries will be limited to 5 followed by the number of omitted summaries.</p>
</div>
<div id="annotation-signals" class="section level2">
<h2>Annotation signals</h2>
<p>Summaries of an annotation signal (ASignal) can be shown with the S3 print() and summary () functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CSignals$<span class="st">`</span><span class="dt">EDF Annotations</span><span class="st">`</span></code></pre></div>
<pre><code>##  Signal number           : 12 
##  Label                   : EDF Annotations 
##  StartTime               : 2009-12-10 12:44:02 
##  Record start specs      : 0 
##  Annotations             : 2 
##  Time first annotation   : 0 sec 
##  Time last annotation    : 600 sec (= 00:10:00)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(ASignalsPeriod$<span class="st">`</span><span class="dt">EDF Annotations</span><span class="st">`</span>)</code></pre></div>
<pre><code>##  Signal number           : 1 3 
##  Label                   : EDF Annotations 
##  StartTime               : 2000-01-01 14:15:16.7 
##  Record start specs      : 0 
##  Annotations             : 6 
##  Time first annotation   : 0.749 sec 
##  Time last annotation    : 1.8 sec</code></pre>
<p>NOTE 1     Because both annotation signals are merged into one, the merged signal is named <code>EDF Annotations</code> again.</p>
<p>NOTE 2     The “Record start specs = 0” indicates that the record start specifications are not included, i.e. readEdfSignals was used with the parameter recordStartTimes = FALSE.</p>
</div>
</div>
<div id="samples-time-and-periods." class="section level1">
<h1>Samples, time and periods.</h1>
<div id="the-start-time" class="section level2">
<h2>The start time</h2>
<p>In case of an EDF or BDF file, the startTime attribute is based on the startdate and starttime in the EDF/BDF header.</p>
<p>The starttime in an EDF/BDF header is specified up to the second.</p>
<p>In EDF+ and BDT+ files a sub second start time can be specified as the start time of the first data record. See the last paragraph in section .2.2.4 of the EDF+ specification.</p>
<p>See, e.g., the startTime for the</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">format</span> (AHdr$startTime, <span class="dt">format=</span><span class="st">&quot;%Y-%m-%d %H:%M:%OS3&quot;</span>,  <span class="dt">usetz =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] &quot;2000-01-01 14:15:16.700&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ASignalsPlusStartTimes &lt;-<span class="st"> </span><span class="kw">readEdfSignals</span>(AHdr, <span class="dt">signals=</span><span class="st">'EDF Annotations-1'</span>, <span class="dt">recordStarts=</span><span class="ot">TRUE</span>)
annots &lt;-<span class="st"> </span>ASignalsPlusStartTimes$annotations
annots[annots$isRecordStart==<span class="ot">TRUE</span>,<span class="st">'onset'</span>][<span class="dv">1</span>]</code></pre></div>
<pre><code>## [1] 0.7</code></pre>
<p>For EDF+ and BDT+ files, the startTime shown by the edfReader is based on both the data in the header and in the start time of the first data record.</p>
</div>
<div id="samples-and-time" class="section level2">
<h2>Samples and time</h2>
<p>As usual, a recording starts at time 0 with sample 1.</p>
<p>Consequently sample n will be at time (n-1)/sRate, where sRate denotes the sample rate.</p>
</div>
<div id="samples-and-periods" class="section level2">
<h2>Samples and periods</h2>
<p>Apart from rounding errors, a from - till period in readEdfSignals will be the period [from,till), i.e. starting at from and up to be but not including till.</p>
<p>This may sound strange, but this convention has the following properties</p>
<ul>
<li><p>the sample rate can be defined as the total number of samples divided by the total time</p></li>
<li><p>or, more precise, any period which is a multiple of the sample period sPeriod will always contain the same number of samples<br />
i.e. for any t ≥ 0, [t, t+n*sPeriod) will always contain n samples</p></li>
<li><p>for any number of adjacent periods, the total number of samples will be always the sum of the samples in the individual periods.</p></li>
<li><p>the first sample will be ceiling(from*sRate) + 1</p></li>
<li><p>the last sample will be ceiling(till*sRate)</p></li>
<li><p>with from=t and till=t, the empty set [t,t) corresponds to [ceiling(t*sRate) + 1, ceiling(t*sRate)] which is also empty.</p></li>
</ul>
</div>
<div id="alignment" class="section level2">
<h2>Alignment</h2>
<div id="the-problem" class="section level3">
<h3>The problem</h3>
<p>In an EDF+/BDF+ file the start of the recording of the signals in a data record is specified in its first annotations signal. For a +D file the recording in a subsequent data record may start at any time after the start of the previous data record plus the record duration time.</p>
<p>The gap between to +D file data records may not be an exact multiple of the sample period of its signals. This raises a question about the alignment of samples in these subsequent data records.</p>
</div>
<div id="two-basic-models." class="section level3">
<h3>Two basic models.</h3>
<p>The alignment of ordinary signals can be modelled in two different ways:</p>
<ol style="list-style-type: upper-alpha">
<li><p>with a interrupted clock<br />
In which case the first sample for every recorded signal is taken at the start of the recording for that data record</p></li>
<li><p>which a continuously running clock<br />
In which case the clock starts at the start of the first record and all sampling is based on the individual signal sample rate(s). In other words, the sample time for a signal sample in the data records is aligned to its sample rate.</p></li>
</ol>
<p>It should be noted that the model with the continuously running clock is (implicitly) required if one want to map all fragments of a signal into a single single (with NA values in the gap) one.</p>
<p>The edfReader supports both models, for any fragment it provides both the aligned data according to the “continuously running clock” model as well as the record start time from the data record.</p>
</div>
<div id="alignment-details" class="section level3">
<h3>Alignment details</h3>
<p>The first sample in every +D record can be aligned as follows:</p>
<pre><code>n = ceiling (sRate * recordStartTime) + 1</code></pre>
<p>and the</p>
<pre><code>sampleTime = (n - 1) / sRate</code></pre>
<p>Where</p>
<ul>
<li><p>sRate is the sample rate</p></li>
<li><p>n is the sample number when continuously sampled from the start of the recording</p></li>
<li><p>recordStartTime denotes the start of the record relative to the start of the recording</p></li>
<li><p>sampleTime the (aligned) sample time for the n’s sample</p></li>
</ul>
<p>However, in order to avoid rounding unnecessary rounding errors the first formula is actually implemented as follows:</p>
<pre><code>n = ceiling (sRate * (recordStartTime - maxTErr)) + 1</code></pre>
<p>Where maxTErr = 5 * .Machine$double.eps (= normally 5 * 2.220446e-16 = 1.110223e-15 )</p>
</div>
</div>
<div id="parameters-involved" class="section level2">
<h2>Parameters involved</h2>
<p>For any signal object and any fragment:</p>
<ul>
<li><p>the ‘start’ parameter contains the aligned signal / fragment start time in seconds, relative to the start in the recording (for a signal it is always 0)</p></li>
<li><p>the ‘fromSample’ parameter contains the sample number for the corresponding sample</p></li>
<li><p>the ‘recordingStart’ parameter contains the start of the recording for the data record. For a ‘+’ file this is the time specified in the first annotation signal</p></li>
<li><p>a ‘from’ parameter in an readEdfSignals invocation is relative to the start of the recording. The default value is 0</p></li>
<li><p>a ‘till’ parameter in an readEdfSignals invocation is relative to the start of the recording. The default value is Inf</p></li>
<li><p>a ‘recordedPeriod’ parameter equals the number of data records times the record duration time as specified in the header</p></li>
<li><p>a totalPeriod parameter contains the period from the start time in the header till the end of the recording, i.e. the record start time of the last data record plus the record duration time</p></li>
</ul>
</div>
</div>
<div id="object-details" class="section level1">
<h1>Object details</h1>
<div id="header-details" class="section level2">
<h2>Header details</h2>
<div id="header-attributes" class="section level3">
<h3>Header attributes</h3>
<p>The header data encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span> (CHdr,  <span class="dt">max.level=</span><span class="dv">1</span>)</code></pre></div>
<pre><code>## List of 17
##  $ fileName           : chr &quot;/Library/Frameworks/R.framework/Versions/3.2/Resources/library/edfReader/extdata/edfPlusC.edf&quot;
##  $ fileType           : chr &quot;EDF&quot;
##  $ version            : chr &quot;0&quot;
##  $ patient            : chr &quot;X X X X&quot;
##  $ recordingId        : chr &quot;Startdate 10-DEC-2009 X X test_generator&quot;
##  $ startTime          : POSIXct[1:1], format: &quot;2009-12-10 12:44:02&quot;
##  $ headerLength       : int 3328
##  $ reserved           : chr &quot;EDF+C&quot;
##  $ nRecords           : int 20
##  $ recordDuration     : num 1
##  $ nSignals           : int 12
##  $ recordedPeriod     : num 20
##  $ sampleBits         : num 16
##  $ isPlus             : logi TRUE
##  $ isContinuous       : logi TRUE
##  $ sHeaders           :Classes 'ebdfSHeaders' and 'data.frame':  12 obs. of  15 variables:
##  $ startSecondFraction: num 0
##  - attr(*, &quot;class&quot;)= chr &quot;ebdfHeader&quot;</code></pre>
<p>The fields version, patient, recordingId, startTime, headerLength, reserved, nRecords, recordDuration, and nSignals are from the file header.</p>
<p>the startSecondFraction attribute contains the sub second start data specified in the first data record. See the ‘The start time’ section above.</p>
<p>NOTE       In order to avoid annoying rounding errors, the sub second start time is stored separately. trunc (startTime, ‘sec’) is less accurate.</p>
<p>sHeader is detailed below. The others attributes are derived ones.</p>
</div>
<div id="signal-header-attributes" class="section level3">
<h3>Signal header attributes</h3>
<p>The signal header data encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span> (CHdr$sHeader, <span class="dt">max.level=</span><span class="dv">1</span>)</code></pre></div>
<pre><code>## Classes 'ebdfSHeaders' and 'data.frame': 12 obs. of  15 variables:
##  $ label           : chr  &quot;squarewave&quot; &quot;ramp&quot; &quot;pulse&quot; &quot;ECG&quot; ...
##  $ transducerType  : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ physicalDim     : chr  &quot;uV&quot; &quot;uV&quot; &quot;uV&quot; &quot;uV&quot; ...
##  $ physicalMin     : num  -1000 -1000 -1000 -1000 -1000 -1000 -1000 -1000 -1000 -1000 ...
##  $ physicalMax     : num  1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 ...
##  $ digitalMin      : int  -32768 -32768 -32768 -32768 -32768 -32768 -32768 -32768 -32768 -32768 ...
##  $ digitalMax      : int  32767 32767 32767 32767 32767 32767 32767 32767 32767 32767 ...
##  $ preFilter       : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ samplesPerRecord: int  200 200 200 200 200 200 200 200 200 200 ...
##  $ reserved        : chr  &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
##  $ gain            : num  0.0305 0.0305 0.0305 0.0305 0.0305 ...
##  $ offset          : num  0.0153 0.0153 0.0153 0.0153 0.0153 ...
##  $ sRate           : num  200 200 200 200 200 200 200 200 200 200 ...
##  $ isAnnotation    : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
##  $ sLength         : int  4000 4000 4000 4000 4000 4000 4000 4000 4000 4000 ...</code></pre>
<p>The fields label, transducerType, physicalDim, physicalMin, physicalMax, digitalMin, digitalMax, preFilter, samplesPerRecord, and reserved are from the file header. The others are derived. Gain and offset are used to map the digital sample values to the range of physical values.</p>
<p>For annotation signals the only relevant fields are “label” which must have the value “EDF Annotations” (or “BDF Annotations”) and “samplesPerRecord”.</p>
</div>
</div>
<div id="signal-details" class="section level2">
<h2>Signal details</h2>
<div id="ordinary-signal-objects-of-class-ebdfcsignal" class="section level3">
<h3>Ordinary signal objects of class ‘ebdfCSignal’</h3>
<p>The data for ordinary signal objects of class ‘ebdfCSignal’ encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(CSignals$pulse, <span class="dt">max.level=</span><span class="dv">1</span>) </code></pre></div>
<pre><code>## List of 17
##  $ signal        : num [1:4000] 99.9924 99.9924 99.9924 99.9924 0.0153 ...
##  $ startTime     : POSIXct[1:1], format: &quot;2009-12-10 12:44:02&quot;
##  $ signalNumber  : int 3
##  $ label         : chr &quot;pulse&quot;
##  $ isContinuous  : logi TRUE
##  $ isAnnotation  : logi FALSE
##  $ recordedPeriod: num 20
##  $ totalPeriod   : num 20
##  $ from          : num 0
##  $ till          : num Inf
##  $ start         : num 0
##  $ fromSample    : num 1
##  $ transducerType: chr &quot;&quot;
##  $ sampleBits    : num 16
##  $ sRate         : num 200
##  $ range         : chr &quot;-1000 : 1000 uV&quot;
##  $ preFilter     : chr &quot;&quot;
##  - attr(*, &quot;class&quot;)= chr &quot;ebdfCSignal&quot;</code></pre>
<p>The attributes startTime, signalNumber, label, isContinuous, isAnnotation, recordedPeriod, totalPeriod, transducerType, sampleBits, sRate, range, and preFilter are (derived) from the header data.</p>
<p>For a continuously recorded signal the totalPeriod is equal to the recordedPeriod. For a not continuously recorded signal the total period equals the start of the last data record plus its duration.</p>
<p>The attributes from and till contain the values of the corresponding actual readEdfSignals parameters. The default values are 0 and Inf.</p>
<p>The start attribute contains the start time and is always zero. The fromSample attribute contains the first sample number and is always 1. By including these attributes, signals and fragments share the same time/sample attributes.</p>
<p>The signal attribute contains the sample data from the EDF / BDF data records. If read with the readEdfSignals parameter physical=TRUE, the default, the digital sample values are mapped to physical values. With physical=FALSE, signals contains the digital sample values.</p>
<p>The physical values are calculated as follows:<br />
 physicalValue = gain * digitalValue + offset,<br />
 with: gain = (physicalMax - physicalMin) / (digitalMax - digitalMin)<br />
 offset = physicalMax - gain * digitalMax</p>
</div>
<div id="ordinary-signal-objects-of-class-ebdffsignal" class="section level3">
<h3>Ordinary signal objects of class ‘ebdfFSignal’</h3>
<p>The data for ordinary signal objects of class ‘ebdfFSignal’ encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(FDSignals$<span class="st">`</span><span class="dt">sine 8.5 Hz</span><span class="st">`</span>, <span class="dt">max.level=</span><span class="dv">1</span>) </code></pre></div>
<pre><code>## List of 17
##  $ startTime     : POSIXct[1:1], format: &quot;2009-12-10 12:44:02&quot;
##  $ signalNumber  : int 8
##  $ label         : chr &quot;sine 8.5 Hz&quot;
##  $ isContinuous  : logi FALSE
##  $ isAnnotation  : logi FALSE
##  $ recordedPeriod: num 11
##  $ totalPeriod   : num 20
##  $ from          : num 0
##  $ till          : num Inf
##  $ start         : num 0
##  $ fromSample    : num 1
##  $ transducerType: chr &quot;&quot;
##  $ sampleBits    : num 16
##  $ sRate         : num 200
##  $ range         : chr &quot;-1000 : 1000 uV&quot;
##  $ preFilter     : chr &quot;&quot;
##  $ fragments     :List of 6
##  - attr(*, &quot;class&quot;)= chr &quot;ebdfFSignal&quot;</code></pre>
<p>For the attributes startTime, signalNumber, label, isContinuous, isAnnotation, recordedPeriod, totalPeriod, from, till, start, fromSample, transducerType, sampleBits, sRate, range and preFilter see the previous section.</p>
<p>For a not continuously recorded signal the total period equals the start of the last data record plus its duration.</p>
<p>The fragments attribute contains the list of recorded fragments.</p>
</div>
<div id="signal-fragment-data" class="section level3">
<h3>Signal fragment data</h3>
<p>The data of a signal fragment in objects of class ‘ebdfFSignal’ encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(FDSignals$<span class="st">`</span><span class="dt">sine 8.5 Hz</span><span class="st">`</span>$fragments[[<span class="dv">1</span>]], <span class="dt">max.level=</span><span class="dv">1</span>) </code></pre></div>
<pre><code>## List of 4
##  $ start         : num 0
##  $ fromSample    : num 1
##  $ recordingStart: num 0
##  $ signal        : num [1:200] 26.4 50.9 71.8 87.6 97.2 ...</code></pre>
<p>The fromSample attribute contains the sample number of the first sample in this fragment (as if it were a continuous recording). The start attribute the sample time for this sample.</p>
<p>The ‘signal’ attribute contains the fragment’s sample values. These may be physical values (the default) or digital values (see above).</p>
</div>
<div id="annotation-signals-1" class="section level3">
<h3>Annotation signals</h3>
<p>The data for annotation signal objects of class ‘ebdfASignal’ encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(ASignals$<span class="st">`</span><span class="dt">EDF Annotations</span><span class="st">`</span>, <span class="dt">max.level=</span><span class="dv">1</span>) </code></pre></div>
<pre><code>## List of 9
##  $ startTime   : POSIXct[1:1], format: &quot;2000-01-01 14:15:16&quot;
##  $ signalNumber: int [1:2] 1 3
##  $ label       : chr &quot;EDF Annotations&quot;
##  $ isContinuous: logi TRUE
##  $ isAnnotation: logi TRUE
##  $ totalPeriod : num 1.2
##  $ from        : num 0
##  $ till        : num Inf
##  $ annotations :'data.frame':    8 obs. of  6 variables:
##  - attr(*, &quot;class&quot;)= chr &quot;ebdfASignal&quot;</code></pre>
<p>For the attributes startTime, signalNumber, label, isContinuous, isAnnotation, totalPeriod, from, and till see the section for objects of class ‘ebdfCSignal’.</p>
<p>The annotations attribute contains a data frame with the individual annotations.</p>
</div>
<div id="annotation-data" class="section level3">
<h3>Annotation data</h3>
<p>The data for a single annotation encompass the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(ASignals$<span class="st">`</span><span class="dt">EDF Annotations</span><span class="st">`</span>$annotations, <span class="dt">max.level=</span><span class="dv">1</span>) </code></pre></div>
<pre><code>## 'data.frame':    8 obs. of  6 variables:
##  $ record       : int  1 2 2 2 11 12 12 12
##  $ onset        : num  0.749 0.8 0.84 0.872 1.719 ...
##  $ duration     : num  NA NA NA 0.005 NA NA 0.005 NA
##  $ isRecordStart: logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
##  $ annotation   : chr  &quot;Test1&quot; &quot;Test2&quot; &quot;Test3&quot; &quot;Test4&quot; ...
##  $ fromSignal   : int  3 1 1 1 3 1 1 1</code></pre>
<p>The record attribute refers to the data record the annotation was read from.</p>
<p>The onset attribute contains the time of the annotation relative to the start of the recording.</p>
<p>The duration attribute contains the duration of the annotated event.</p>
<p>The isRecordStart indicates whether or not this annotation is the first one in a data record (and indicates the start time of the recording of that record).</p>
<p>The annotation attribute contains the annotations associated with the onset and duration.</p>
<p>The fromSignal attribute, if present, refers to the signal that contains the annotation. This attributed is present only if the annotations from different signals were merged into one ‘ebdfASignal’ object.</p>
</div>
</div>
</div>
<div id="acknowledgement" class="section level1">
<h1>Acknowledgement</h1>
<p>This package has used code from</p>
<ul>
<li><p>edf.R version 0.3 (27-11-2013) from from Fabien Feschet,<br />
<a href="http://data-auvergne.fr/cloud/index.php/s/WYmFEDZylFWJzNs" class="uri">http://data-auvergne.fr/cloud/index.php/s/WYmFEDZylFWJzNs</a></p></li>
<li><p>the work of Henelius Andreas as of July 2015,<br />
<a href="https://github.com/bwrc/edf" class="uri">https://github.com/bwrc/edf</a></p></li>
</ul>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<ol style="list-style-type: decimal">
<li><p>Specification of EDF<br />
<a href="http://www.edfplus.info/specs/edf.html" class="uri">http://www.edfplus.info/specs/edf.html</a></p></li>
<li><p>Specification of EDF+<br />
<a href="http://www.edfplus.info/specs/edfplus.html" class="uri">http://www.edfplus.info/specs/edfplus.html</a></p></li>
<li><p>Specification of EDF++<br />
<a href="http://195.154.67.227/en/contribute/edf/" class="uri">http://195.154.67.227/en/contribute/edf/</a></p></li>
<li><p>Specification of BDF<br />
see ‘Which file format does BioSemi use’ at<br />
<a href="http://www.biosemi.com/faq/file_format.htm" class="uri">http://www.biosemi.com/faq/file_format.htm</a></p></li>
<li><p>Specification of BDF+<br />
<a href="http://www.teuniz.net/edfbrowser/bdfplus%20format%20description.html">http://www.teuniz.net/edfbrowser/bdfplus%20format%20description.html</a></p></li>
</ol>
<p>Other useful EDF related sources can be found at:<br />
<a href="http://www.edfplus.info/downloads/" class="uri">http://www.edfplus.info/downloads/</a> /</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
